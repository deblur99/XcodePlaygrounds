# 디자인 패턴

## 생성 패턴 (Creational Patterns)

### 싱글턴 (Singleton)
앱 전체에서 동일한 상태값을 가지는 인스턴스를 생성하고 관리하는 패턴
- Race condition과 같은 상황에 대비하기 위한 여러 선언 방법이 있음
- Swift 최신 버전에서는 여기에 actor 개념을 도입하여 관련 문제점을 해결 


### 팩토리 메서드 (Factory Method)
상위 인터페이스에서 객체 생성에 필요한 부분을 정의하고, **실제 객체 생성은 하위 클래스에서 담당**
- 추상 팩토리 클래스와 그 내부에서 인터페이스 객체를 생성하여 반환하는 메서드 두 가지가 있음
- 이 2가지를 구현해서 해당 구현 클래스의 객체 생성 메서드를 호출하여 원하는 객체 생성  


### 추상 팩토리 (Abstract Factory)
서로 연관되거나 의존적인 객체를 일관된 방식으로 조합해 생성할 수 있는 인터페이스를 제공하는 디자인 패턴
- 팩토리 메서드와 비슷한데, 팩토리 메서드는 객체 생성해서 반환하는 메서드가 하나라면 추상 팩토리는 서로 다른 반환형의 메서드가 여러 개라는 점 
    - 팩토리 추상 클래스에서 생성해야 하는 하위 속성이 여러 개인데 해당 속성들도 별도의 인터페이스를 가짐
    - 그래서 팩토리 추상 클래스와 여기서 생성하는 하위 속성 인터페이스들을 추가로 구현해서
    - 팩토리 구현 클래스에 맞는 하위 속성 인터페이스들도 맞춤으로 구현함


### 빌더 (Builder)
복잡한 객체 생성을 단계에 따라 안전하게 구성하도록 돕는 생성 패턴
- **메서드 체이닝 방식으로 필요한 속성만 골라서 설정**하고, 인스턴스를 생성할 수 있음
- 안드로이드에서는 AlertDialog 생성 시 사용됨
- Swift에서는 생성자에 기본값을 지정할 수 있고, 그렇게 지정된 항목은 생성자 호출 시 생략이 가능하다. 그래서 거의 쓰이지 않는 패턴임


## 구조 패턴 (Structural Patterns)

### 어댑터 (Adapter)
**서로 호환되지 않는 인터페이스**를 사용하는 클래스들이 상호 호환되어 동작할 수 있도록 연결해주는 패턴
- 클래스 어댑터: 상속을 통해 기존 인터페이스를 새로운 방식으로 변환
    - 구성요소
        - Adaptee: Adapter 클래스가 필요한 대상 객체, 주로 기존 시스템에서 제공하는 클래스를 의미
        - Adapter: Target 인터페이스와 Adaptee 클래스를 연결하는 역할 담당. 클래스 어댑터에서는 Adaptee 클래스를 상속하고, Target 인터페이스를 구현함.
        - Target: 변환 대상인 인터페이스로, 기존 시스템의 기능을 Adapter 클래스가 호출하도록 정의된 것
    - Adapter는 Adaptee를 Target으로 변환한다.
    - 상속을 사용하므로 유연성이 떨어지며, 다중 상속을 지원하지 않는 언어에서는 권장되지 않음
    
- **객체 어댑터**: 클래스 어댑터보다 유연하며 권장되는 방식
    - Adapter가 Adaptee 클래스를 상속하는 클래스 어댑터 방식과 달리, Adaptee 클래스의 **인스턴스를 Adapter의 속성으로 가진다**는 점에서 차이가 있음
    - Target 인터페이스에서 호출하고자 하는 메서드를 Adapter에서 구현하는데, 여기서 Adaptee 인스턴스에서 호출하고자 하는 메서드를 호출하면 된다.


### 데코레이터 (Decorator)
객체에 동적으로 새로운 기능을 덧붙일 수 있게 해주는 패턴
- 여러 가지 특징을 추가하는 상황이며 그 특징들 간 조합이 엄청나게 많은 상황일 때, 데코레이터를 쓰지 않으면 각 조합별 클래스를 새로 만드는 불편함이 생긴다.
- 데코레이터 패턴은 기존 코드를 수정하지 않고 기능 확장과 변경을 간편하게 할 수 있으며, 필요에 따라 여러 데코레이터를 조합해서 다양한 기능을 유연하게 구현할 수 있다.
- Swift에서는 프로토콜을 만들고, 해당 프로토콜을 채택하고 적용할 인스턴스도 프로토콜을 타입으로 하여 선언


### 컴포지트 (Composite)
복잡한 전체-부분 관계를 효율적으로 정의하고, 객체 간 결합도를 낮춰 유연성과 유지보수성을 높이는 패턴
- 객체들이 재귀적으로 연결되어 트리 형태를 구성할 떄, 복합 객체와 단일 객체를 동일 인터페이스로 다룰 수 있도록 설계
- 1:N 관계의 트리 구조 ex) 조직-구성원, 폴더-파일
- 컴포지트의 구성 요소
    - Component: Leaf와 Composite를 묶는 상위 인터페이스. 이를 통해 클라이언트가 단일 객체와 복합 객체를 동일한 방식으로 다룰 수 있음
    - Leaf: 단일 객체. operation 함수는 해당 객체가 수행해야 하는 적절한 값을 반환
    - Composite: 복합 객체. operation 함수를 호출하면 내부에 포함된 Component 리스트를 재귀적으로 순회하면서 작업을 위임함. 이때 Leaf 객체면 해당 객체의 값을 반환하고, Composite 객체라면 해당 Composite 객체 내부의 리스트를 이어서 순회한다. 이를 통해 전체 객체를 탐색할 수 있게 됨
    
```
Composite는 Leaf를 자식 요소로 두어, Composite 내부의 Leaf를 탐색하고 반환함
트리 구조를 구현하기 좋은 패턴!
```

### 브릿지 (Bridge)
큰 규모의 클래스나 밀접하게 연관된 클래스를 **추상 계층과 구현부로 분리**하여, **각각 독립적으로 확장 또는 변경**할 수 있도록 하는 패턴
- 추상 계층은 인터페이스 (프로토콜)로 처리하고, 구현부는 추상 계층에 생성자로 주입하는 인스턴스로 처리한다.
- 코드의 복잡도를 올리는 패턴
    - 기능 확장이 자주 발생하면 채택해볼 만한 패턴이지만, 실제로 그렇지 않을 경우 불필요한 복잡도만 초래할 수 있다.


## 행동 패턴 (Behavioral Patterns)

### 스트래티지 (Strategy)
런타임에서 변할 수 있는 동작을 담당하는 별도의 인터페이스와 그 구현 클래스를 만들어서, 이를 사용하는 클래스에서 인스턴스를 가져서 사용하는 패턴 

### 옵저버 (Observer)
관찰 대상 (Subject)의 상태가 변경될 때, 이를 관찰하는 모든 객체 (Observer)에게 이벤트나 알림을 전달하는 패턴
- 앱에서는 MVVM을 비롯한 패턴 구현에서 널리 사용되며, 서버에서는 메시지 브로커와 같은 형태로 널리 사용된다.
    - LiveData, Flow / Combine, Rx, ...
    
- 구성 요소
    - Subject: 관찰 대상이 되는 객체로, 여러 개의 Observer 객체를 가지고 있음. 어떤 이벤트를 방출할 때 가지고 있던 Observer 객체들에게 한꺼번에 이벤트를 전달함
    - Observer: 관찰자가 되는 객체를 생성하는 인터페이스. 알림 처리 (콜백)를 위한 notify 함수가 선언되어 있음.
    - ConcreteObserver: Observer 인터페이스의 구현 클래스로, 이벤트가 방출되면 notify 함수 내에서 필요한 동작 수행

### 이터레이터 (Iterator)
컬렉션 요소에 순차적으로 접근할 수 있도록 도와주는 패턴
- 구성 요소
    - Iterator: 컬렉션 요소를 순차적으로 검색하는 인터페이스. 기본적으로 다음 요소가 존재하는지 확인하는 hasNext() 함수와, 요소를 반환하고 다음 요소로 이동하는 next() 함수로 되어 있다.
        - hasNext()로 다음 요소가 있는지 확인하고, 있다면 next()로 다음 요소를 가져오고 그 다음 요소를 가져올 준비를 한다.
    - ConcreteIterator: Iterator의 구현체로, ConcreteCollection 내부 요소를 순차적으로 탐색하는 역할을 한다.  
    - IterableCollection: Iterator를 반환하는 함수를 정의하는 인터페이스. 컬렉션과 호환되는 반복자를 얻는 함수를 선언하며, 해당 함수의 반환 자료형은 Iterator여야 한다.
    - ConcreteCollection: IterableCollection 인터페이스의 구현체. 클라이언트가 사용할 객체 컬렉션을 내부에 가지고 있다. 이를 통해 반복자 객체를 반환한다.

```대부분의 모던 프로그래밍 언어는 for each 구문이나 forEach() 고차 함수를 통해 기본적으로 이터레이터와 유사한 기능을 쓸 수 있다. 따라서 굳이 직접 구현할 필요는 없다.```

### 스테이트 (State)
객체의 상태에 따라 서로 다른 동작을 수행하도록 설계한 패턴
- 어떤 클래스의 상태값을 저장하는 별도의 클래스를 선언하고, 그 클래스의 인스턴스를 해당 클래스의 내부에 저장
- 상태값을 저장하는 클래스의 인스턴스를 갖는 클래스에서는, 인스턴스의 상태값을 바꿀 수 있는 메서드를 선언
- 클래스 외부에서 상태값을 변경할 때에는 앞서 선언해둔 상태값 바꾸는 메서드를 호출함으로써 변경 시도
- 이를 통해 클래스 외부에서 상태값을 알 필요 없다는 은닉화의 장점과, 상태를 관리하는 부분을 캡슐화하는 장점을 챙길 수 있다. 

### 메디에이터 (Mediator)
복잡한 N:M 객체 관계일 경우, 중재자를 도입해서 M:1 관계로 단순화하는 패턴
- 객체 간 직접적인 의존성을 줄이고, 중재자를 통해 상호작용을 관리할 수 있음
- 복잡하게 직접 연동하던 객체들을 하나의 중재자 객체로 캡슐화하여, 객체들이 서로 직접 연동하지 않고 중재자를 통해 상호작용하는 방법을 제안함.
    - 객체 간의 결합도를 낮추고 복잡한 관계를 단순하게 정리하는 데 효과적 (네트워크 토폴로지의 Mesh -> Star로 바꾼다는 느낌)
- 기존에 서로 의존하던 객체를 클라이언트라고 하면, 이들 간 상호작용을 중재하는 중재자는 서버라고 생각하면 편하다.
    - 객체 간에 직접 상호작용하는 것 대신 중재자를 거쳐서 간접적인 상호작용을 하게 되었다고 생각하기

```
MediatorLiveData?
``` 

## MVC 패턴



## (추가) Swift 앱에서 쓰이는 패턴들

```
여기에 다루기는 너무 많으니 간단히만 소개
```

### MVVM
 
 
### RIB


### Viper


### TCA
