```
클린 코드의 기준은 시대에 따라 변한다.

불과 몇십 년 전만 해도 코드에서 가독성을 고려하는 것은 사치로 여겼습니다. (중략) 그 당시에는 어떻게 하면 메모리를 덜 사용하고, 프로그램을 더 짧은 시간 안에 실행할 수 있는지가 최우선 가치였습니다.

그러나, 시대가 바뀌면서, 컴퓨터는 1초면 부팅되고 유튜브 영상을 실시간으로 시청하는 것도 가능해졌습니다. 이에 따라 클린 코드의 기준도 바뀌었습니다.

예전에는 잦은 함수 호출이 성능 저하를 유발한다고 여겨, 가독성이 다소 떨어지더라도 긴 함수를 사용하는 것을 선호했습니다. 하지만 지금은 강력한 컴퓨팅 파워 덕분에 더 이상 긴 함수를 고집할 필요가 없어졌고, 오히려 짧고 명확한 함수를 작성해 코드 가독성과 유지 보수성을 높이는 방향이 주류가 되었습니다.
```


## 이 장에서 다뤄진 리팩토링 기법들
- 코드 정리
    - 변수는 사용하는 위치 가까이에 선언하기
    - 코딩 스타일 통일하기
- 초기화 구문 분리
- 메서드 하나가 여러 역할을 수행하는 경우, 각 역할마다 메서드 분리
- 복잡한 조건문 분리
- 처리 결과값을 Bool로 반환하는 것보다, do/catch 예외 구문으로 처리
- 다형성 이용하기
    - Swift에서는 서브클래싱을 통한 다형성 대신 프로토콜을 통한 다형성이 훨씬 많이 쓰인다.
- 같은 범주의 속성을 별도의 타입으로 분리하고, 해당 타입의 인스턴스를 가지게 하기
    - struct 서브 타입을 사용

## 팁
함수나 클래스의 내용이 너무 길어져, 책임이 많아지면 코드 스멜 -> 결합도 높아짐 -> 향후 유지보수 및 코드 확장에 어려움
함수, 클래스 내부의 기능을 별도의 함수 또는 서브클래스로 분리
- Swift에서는 서브클래스 대신 프로토콜/익스텐션 분리하여 채택, 별도의 타입으로 분리하고 인스턴스로 가지는 방법 사용
그렇다고 지나치게 많이 분리하면, '조각' 코드가 되어 오히려 구조를 이해하기 어려워지게 된다. 적당한 크기와 가독성을 고려해 나누는 것이 좋다.
좋은 코드를 작성하려면 선배 개발자들의 경험과 지식을 바탕으로, 스스로의 경험과 고민을 통해 지속적으로 발전시켜 나가는 태도를 가져야 한다.

인라인 코드로 분리하기
- 어떤 함수가 처리하는 기능이 적을 땐, 클래스 내부에서 자체적으로 처리하는 방법도 좋은 선택

기능 편애 (feature envy)에 유의
- 기능 편애: 특정 클래스에 있는 함수가 자신이 속한 모듈의 데이터나 함수를 사용하기보다, 다른 모듈에 있는 요소들을 과도하게 참조하는 경우
- 함수가 동작할 때 같은 클래스의 변수나 함수를 활용하지 않고 다른 모듈의 요소들을 많이 참조하게 되어, 응집도가 낮아지고 결합도가 높아지는 코드 스멜로 이어진다.  
- 기능 편애를 제거하는 방법
    1. 다른 클래스의 필드나 함수를 참조하는 부분을 단순화하여 참조 횟수 줄이기
        - ex) 다른 클래스의 필드들의 합계를 가져올 때, 필드들을 하나씩 가져와 합계를 직접 구하기보다 합계를 구하는 연산 프로퍼티를 의존하는 클래스 내부에 선언하고 그걸 가져오는 방식으로 변경 
    2. 참조 대상 필드나 함수를 해당 요소를 소유한 클래스로 옮기기

과도한 매개변수 줄이기
- 클래스 내부에서 중복하여 쓰는 매개변수와 지역변수는 별도의 연산 프로퍼티 혹은 메서드로 분리
- 플래그용 매개변수는 호출하는 부분에서 어떤 의미인지 확인하기 어려움. 그러므로, 분기하고자 하는 내용이 포함된, 포함되지 않는 메서드 2가지로 분리하여 이를 호출하는 쪽이 명확함
- 매개변수가 4개, 5개 이상으로 많아지는 경우 하나의 타입으로 캡슐화하고, 해당 타입의 인스턴스를 대신 넘기기

매직넘버 최대한 지양하기
- 매직넘버: 특정한 숫자, 문자, 문자열을 그대로 하드코딩하는 경우
- 매직넘버를 사용하면 다른 사람이 이걸 왜 썼는지 파악하기 어려울 수 있음
- 따라서 별도의 상수로 분리해야 함

```
매직 넘버는 예외없이 리팩토링하여 제거해야 한다.
```
